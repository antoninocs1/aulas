# Controle de Dados

## GRANT/REVOKE

Os comandos `GRANT` e `REVOKE` são utilizados no SQL para conceder e revogar permissões de acesso a objetos do banco de dados, garantindo um controle adequado sobre a segurança dos dados.

- Cada objeto do banco de dados tem um dono (*owner*), que é o seu criador.
- Apenas o criador ou dono pode acessar os objetos inicialmente.
- O SQL oferece um esquema de permissões através dos comandos `GRANT` e `REVOKE` para permitir ou restringir o acesso a outros usuários.

## GRANT

O comando `GRANT` é utilizado para conceder permissões a usuários específicos ou públicos para realizar determinadas operações no banco de dados.

### Permissão de comandos DDL
O `GRANT` pode ser usado para conceder permissões sobre comandos de manipulação da estrutura do banco de dados (DDL - *Data Definition Language*).

```sql
GRANT {comando} TO {usuário};
```

### Permissão de acesso a objetos
O `GRANT` também permite definir permissões específicas sobre tabelas, visões e outros objetos do banco de dados.

```sql
GRANT {comando} ON {object} TO {usuário} [WITH GRANT OPTION];
```

- **MS SQL Server** – Especifica colunas após `{object}`.
- **Oracle** – Especifica colunas após `{comando}`.

### Opção `WITH GRANT OPTION`
Ao adicionar `WITH GRANT OPTION`, o usuário que recebeu a permissão pode conceder a mesma permissão a outros usuários.

### Exemplos de `GRANT`
```sql
GRANT ALTER ON empregado TO alan;
GRANT SELECT, INSERT, UPDATE, DELETE ON empregado TO alan;
GRANT ALL ON empregado TO alan;
GRANT SELECT ON departamento TO alan WITH GRANT OPTION;
```

## REVOKE

O comando `REVOKE` é utilizado para retirar as permissões previamente concedidas a um usuário.

```sql
REVOKE {comando} ON {object} FROM {usuário};
```

### Importância do `REVOKE`
- Permite revogar acessos de usuários quando não são mais necessários.
- Pode ser usado para restringir privilégios que foram concedidos acidentalmente ou que não são mais adequados.
- Se um usuário perder uma permissão que recebeu com `WITH GRANT OPTION`, todas as permissões concedidas por ele a outros usuários também serão removidas.

### Exemplos de `REVOKE`
```sql
REVOKE DELETE ON empregado FROM alan;
REVOKE ALL ON empregado FROM alan;
REVOKE ALL ON empregado FROM PUBLIC;
```

## Especificação de Restrições Básicas em SQL

Além das restrições de chave, é possível incluir restrições adicionais de domínio para garantir a integridade dos dados.

### CHECK Constraint
A restrição `CHECK` é usada para definir uma condição que os valores de uma coluna devem satisfazer. Se um valor não atender à condição especificada, a inserção ou atualização da linha será rejeitada.

### Restrições sobre Campos
As restrições podem ser aplicadas diretamente nas colunas da tabela para impor regras de integridade.

```sql
CREATE TABLE Produto (
    Codigo VARCHAR(20),
    Nome VARCHAR(50),
    Saldo NUMBER,
    CHECK (Saldo BETWEEN 0 AND 40)
);
```

### Restrições sobre Tuplas
As restrições também podem ser adicionadas para garantir relações entre os valores das colunas.

```sql
ALTER TABLE entrega ADD
    CHECK (DataSaida <= DataChegada);
```

## Gatilhos ou Triggers

Os *Triggers* são procedimentos armazenados que são automaticamente executados em resposta a eventos específicos em uma tabela, como operações `INSERT`, `UPDATE` ou `DELETE`.

### Tipos de Triggers

1. **BEFORE TRIGGER**: Executa antes da operação (`INSERT`, `UPDATE`, `DELETE`).
2. **AFTER TRIGGER**: Executa após a operação.
3. **INSTEAD OF TRIGGER**: Substitui a operação original, muito útil para `VIEWs`.

### Criando um Trigger para Auditoria de Alterações no Salário

O exemplo abaixo cria um *trigger* que registra todas as alterações feitas no atributo `salario` de um empregado na tabela `Audit_Salario`.

```sql
CREATE TABLE Audit_Salario (
    ID NUMBER(6),
    data DATE,
    new_sal NUMBER(8,2),
    old_sal NUMBER(8,2)
);

CREATE OR REPLACE TRIGGER Audit_sal
AFTER UPDATE OF salario ON Empregado FOR EACH ROW
BEGIN
    INSERT INTO Audit_Salario VALUES(:OLD.Matricula, SYSDATE, :NEW.salario, :OLD.salario);
END;
```

CREATE TABLE Audit_Salario: Esse comando cria uma nova tabela chamada Audit_Salario no banco de dados. O propósito dessa tabela é armazenar as alterações nos salários dos empregados.

- ID NUMBER(6): A coluna ID é do tipo NUMBER(6), ou seja, pode armazenar números com até 6 dígitos. Essa coluna é usada para registrar o identificador do empregado, que provavelmente seria o número de matrícula do empregado (exemplo: Matricula na tabela Empregado).

- data DATE: A coluna data armazena a data em que a alteração foi realizada. O tipo de dado é DATE, que armazena data e hora.

- new_sal NUMBER(8,2): A coluna new_sal armazena o novo salário do empregado. O tipo de dado NUMBER(8,2) significa que o valor pode ter até 8 dígitos no total, sendo 2 deles após o ponto decimal (por exemplo, 999999.99).

- old_sal NUMBER(8,2): A coluna old_sal armazena o salário anterior do empregado, no mesmo formato do new_sal.

- CREATE OR REPLACE TRIGGER Audit_sal: Este comando cria ou substitui o trigger chamado Audit_sal. Um trigger é um tipo de objeto do banco de dados que executa automaticamente uma ação quando ocorre um evento específico (como uma atualização, inserção ou exclusão).

- AFTER UPDATE OF salario ON Empregado: Define que o trigger será acionado depois de uma atualização na tabela Empregado, especificamente quando a coluna salario for alterada. Ou seja, sempre que o salário de um empregado for modificado, o trigger será executado.

- FOR EACH ROW: Esta cláusula indica que o trigger será executado para cada linha afetada pela atualização. Isso significa que, se a atualização alterar múltiplas linhas, o trigger será executado uma vez para cada linha afetada.

- BEGIN ... END;: O código entre BEGIN e END define o que o trigger irá fazer quando for acionado. No caso deste trigger, ele executa uma ação de inserção na tabela Audit_Salario.

- INSERT INTO Audit_Salario (ID, data, new_sal, old_sal): O trigger insere uma nova linha na tabela Audit_Salario, registrando os dados relacionados à alteração do salário.

- VALUES(:OLD.Matricula, SYSDATE, :NEW.salario, :OLD.salario);: O comando INSERT insere os valores nas colunas da tabela Audit_Salario:

- :OLD.Matricula: Refere-se ao valor antigo da coluna Matricula (matrícula do empregado) na linha antes de ser alterada.
SYSDATE: Retorna a data e hora atuais do sistema, que é registrada como a data da alteração.
- :NEW.salario: Refere-se ao novo valor da coluna salario na linha após a atualização.
- :OLD.salario: Refere-se ao valor antigo da coluna salario antes da atualização.

Para testar o *trigger*, podemos executar o seguinte comando:

```sql
UPDATE empregado SET salario = salario * 1.01 WHERE Bairro = 'Pituba';
```

Em seguida, podemos verificar os registros na tabela de auditoria:

```sql
SELECT * FROM Audit_Salario;
```

### Criando Triggers para Atualizar o Campo `TotalSal` na Tabela `Departamento`

```sql
    ALTER TABLE Departamento ADD TotalSal NUMBER;
    UPDATE Departamento SET TotalSal = 0;

    CREATE TRIGGER TotalSalario
    AFTER INSERT ON empregado FOR EACH ROW
    BEGIN
        UPDATE departamento
        SET totalsal = totalsal + :new.salario
        WHERE cod = :new.coddepart;
    END;
```

- Acrescenta a coluna TotalSal na tabela Departamento para armazenar o total dos salários dos empregados de cada departamento.
- Garante que todos os departamentos começam com um total de salários igual a 0.
- Esse trigger é acionado depois (AFTER) de uma inserção (INSERT) na tabela Empregado.
Para cada nova linha adicionada (FOR EACH ROW), ele:
- Atualiza a tabela Departamento, somando o valor do salário recém-inserido (:NEW.- salario) ao total acumulado (TotalSal).
- Usa :NEW.coddepart para garantir que a atualização seja feita no departamento correto.



### Exemplo de INSTEAD OF TRIGGER para VIEW

Se tivermos uma `VIEW` chamada `Empregado_Departamento`, podemos criar um `INSTEAD OF TRIGGER` para gerenciar inserções:

```sql
CREATE VIEW Empregado_Departamento AS
SELECT e.Matricula, e.Nome, d.Nome AS Departamento
FROM Empregado e
JOIN Departamento d ON e.CodDepart = d.Cod;

CREATE TRIGGER InsteadOfInsertEmpDept
INSTEAD OF INSERT ON Empregado_Departamento
FOR EACH ROW
BEGIN
    INSERT INTO Empregado (Matricula, Nome, CodDepart)
    VALUES (:NEW.Matricula, :NEW.Nome, (SELECT Cod FROM Departamento WHERE Nome = :NEW.Departamento));
END;
```

- A view exibe informações dos empregados junto com o nome de seu respectivo departamento.
- Os dados vêm de uma junção (JOIN) entre as tabelas Empregado e Departamento.
- A coluna CodDepart da tabela Empregado é usada para ligar com a coluna Cod da tabela Departamento.
- Esse trigger é do tipo INSTEAD OF INSERT, que substitui a tentativa de inserção direta na view por outra ação.
- Ele intercepta qualquer comando INSERT na view Empregado_Departamento e, em vez disso, insere os dados diretamente na tabela Empregado.
- Como a view não possui a coluna CodDepart (somente Departamento), o trigger faz uma subconsulta para buscar o código (Cod) correspondente ao nome do departamento (:NEW.Departamento).
- Assim, o novo empregado é inserido corretamente na tabela Empregado, mantendo a integridade dos dados.


Esse `INSTEAD OF TRIGGER` permite que insiramos dados na `VIEW`, e o banco de dados automaticamente os distribua para as tabelas correspondentes.

---

Os *triggers* são ferramentas poderosas para garantir integridade, automação de regras de negócio e auditoria dentro de um banco de dados relacional.
