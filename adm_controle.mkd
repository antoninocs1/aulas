# Controle de Dados

## GRANT/REVOKE

Os comandos `GRANT` e `REVOKE` são utilizados no SQL para conceder e revogar permissões de acesso a objetos do banco de dados, garantindo um controle adequado sobre a segurança dos dados.

- Cada objeto do banco de dados tem um dono (*owner*), que é o seu criador.
- Apenas o criador ou dono pode acessar os objetos inicialmente.
- O SQL oferece um esquema de permissões através dos comandos `GRANT` e `REVOKE` para permitir ou restringir o acesso a outros usuários.

## GRANT

O comando `GRANT` é utilizado para conceder permissões a usuários específicos ou públicos para realizar determinadas operações no banco de dados.

### Permissão de comandos DDL
O `GRANT` pode ser usado para conceder permissões sobre comandos de manipulação da estrutura do banco de dados (DDL - *Data Definition Language*).

```sql
GRANT {comando} TO {usuário};
```

### Permissão de acesso a objetos
O `GRANT` também permite definir permissões específicas sobre tabelas, visões e outros objetos do banco de dados.

```sql
GRANT {comando} ON {object} TO {usuário} [WITH GRANT OPTION];
```

- **MS SQL Server** – Especifica colunas após `{object}`.
- **Oracle** – Especifica colunas após `{comando}`.

### Opção `WITH GRANT OPTION`
Ao adicionar `WITH GRANT OPTION`, o usuário que recebeu a permissão pode conceder a mesma permissão a outros usuários.

### Exemplos de `GRANT`
```sql
GRANT ALTER ON empregado TO alan;
GRANT SELECT, INSERT, UPDATE, DELETE ON empregado TO alan;
GRANT ALL ON empregado TO alan;
GRANT SELECT ON departamento TO alan WITH GRANT OPTION;
```

## REVOKE

O comando `REVOKE` é utilizado para retirar as permissões previamente concedidas a um usuário.

```sql
REVOKE {comando} ON {object} FROM {usuário};
```

### Importância do `REVOKE`
- Permite revogar acessos de usuários quando não são mais necessários.
- Pode ser usado para restringir privilégios que foram concedidos acidentalmente ou que não são mais adequados.
- Se um usuário perder uma permissão que recebeu com `WITH GRANT OPTION`, todas as permissões concedidas por ele a outros usuários também serão removidas.

### Exemplos de `REVOKE`
```sql
REVOKE DELETE ON empregado FROM alan;
REVOKE ALL ON empregado FROM alan;
REVOKE ALL ON empregado FROM PUBLIC;
```

## Especificação de Restrições Básicas em SQL

Além das restrições de chave, é possível incluir restrições adicionais de domínio para garantir a integridade dos dados.

### CHECK Constraint
A restrição `CHECK` é usada para definir uma condição que os valores de uma coluna devem satisfazer. Se um valor não atender à condição especificada, a inserção ou atualização da linha será rejeitada.

### Restrições sobre Campos
As restrições podem ser aplicadas diretamente nas colunas da tabela para impor regras de integridade.

```sql
CREATE TABLE Produto (
    Codigo VARCHAR(20),
    Nome VARCHAR(50),
    Saldo NUMBER,
    CHECK (Saldo BETWEEN 0 AND 40)
);
```

### Restrições sobre Tuplas
As restrições também podem ser adicionadas para garantir relações entre os valores das colunas.

```sql
ALTER TABLE entrega ADD
    CHECK (DataSaida <= DataChegada);
```

## Gatilhos ou Triggers

Os *Triggers* são procedimentos armazenados que são automaticamente executados em resposta a eventos específicos em uma tabela, como operações `INSERT`, `UPDATE` ou `DELETE`.

### Tipos de Triggers

1. **BEFORE TRIGGER**: Executa antes da operação (`INSERT`, `UPDATE`, `DELETE`).
2. **AFTER TRIGGER**: Executa após a operação.
3. **INSTEAD OF TRIGGER**: Substitui a operação original, muito útil para `VIEWs`.

### Criando um Trigger para Auditoria de Alterações no Salário

O exemplo abaixo cria um *trigger* que registra todas as alterações feitas no atributo `salario` de um empregado na tabela `Audit_Salario`.

```sql
CREATE TABLE Audit_Salario (
    ID NUMBER(6),
    data DATE,
    new_sal NUMBER(8,2),
    old_sal NUMBER(8,2)
);

CREATE OR REPLACE TRIGGER Audit_sal
AFTER UPDATE OF salario ON Empregado FOR EACH ROW
BEGIN
    INSERT INTO Audit_Salario VALUES(:OLD.Matricula, SYSDATE, :NEW.salario, :OLD.salario);
END;
```

Para testar o *trigger*, podemos executar o seguinte comando:

```sql
UPDATE empregado SET salario = salario * 1.01 WHERE Bairro = 'Pituba';
```

Em seguida, podemos verificar os registros na tabela de auditoria:

```sql
SELECT * FROM Audit_Salario;
```

### Criando Triggers para Atualizar o Campo `TotalSal` na Tabela `Departamento`

```sql
ALTER TABLE Departamento ADD TotalSal NUMBER;
UPDATE Departamento SET TotalSal = 0;

CREATE TRIGGER TotalSalario
AFTER INSERT ON empregado FOR EACH ROW
BEGIN
    UPDATE departamento
    SET totalsal = totalsal + :new.salario
    WHERE cod = :new.coddepart;
END;
```

### Exemplo de INSTEAD OF TRIGGER para VIEW

Se tivermos uma `VIEW` chamada `Empregado_Departamento`, podemos criar um `INSTEAD OF TRIGGER` para gerenciar inserções:

```sql
CREATE VIEW Empregado_Departamento AS
SELECT e.Matricula, e.Nome, d.Nome AS Departamento
FROM Empregado e
JOIN Departamento d ON e.CodDepart = d.Cod;

CREATE TRIGGER InsteadOfInsertEmpDept
INSTEAD OF INSERT ON Empregado_Departamento
FOR EACH ROW
BEGIN
    INSERT INTO Empregado (Matricula, Nome, CodDepart)
    VALUES (:NEW.Matricula, :NEW.Nome, (SELECT Cod FROM Departamento WHERE Nome = :NEW.Departamento));
END;
```

Esse `INSTEAD OF TRIGGER` permite que insiramos dados na `VIEW`, e o banco de dados automaticamente os distribua para as tabelas correspondentes.

---

Os *triggers* são ferramentas poderosas para garantir integridade, automação de regras de negócio e auditoria dentro de um banco de dados relacional.
